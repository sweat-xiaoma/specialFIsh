declare module dcodeIO {
	export class ByteBuffer {
		public buffer:number;
		public view:number;
		public offset:number;
		public markedOffset:number;
		public limit:number;
		public littleEndian:boolean;
		public noAssert:boolean;
		public static VERSION:string;
		public static LITTLE_ENDIAN:boolean;
		public static BIG_ENDIAN:boolean;
		public static DEFAULT_CAPACITY:number;
		public static DEFAULT_ENDIAN:boolean;
		public static DEFAULT_NOASSERT:boolean;
		public static Long:any;
		public static accessor():any;
		public static allocate(capacity?:number, littleEndian?:boolean, noAssert?:boolean):ByteBuffer;
		public static concat(buffers:any, encoding?:any, littleEndian?:boolean, noAssert?:boolean):ByteBuffer;
		public static isByteBuffer(bb:any):boolean;
		public static type():any;
		public static wrap(buffer:any, encoding?:any, littleEndian?:boolean, noAssert?:boolean):ByteBuffer;
		constructor(capacity?:number, littleEndian?:boolean, noAssert?:boolean);
		public writeBitSet(value:boolean[], offset?:number):ByteBuffer;
		public readBitSet(offset?:number):boolean[];
		public readBytes(length:number, offset?:number):ByteBuffer;
		public writeInt8(value:number, offset?:number):ByteBuffer;
		public writeByte(value:number, offset?:number):ByteBuffer;
		public readInt8(offset?:number):number;
		public readByte(offset?:number):number;
		public writeUint8(value:number, offset?:number):ByteBuffer;
		public writeUInt8(value:number, offset?:number):ByteBuffer;
		public readUint8(offset?:number):number;
		public readUInt8(offset?:number):number;
		public writeInt16(value:number, offset?:number):ByteBuffer;
		public writeShort(value:number, offset?:number):ByteBuffer;
		public readInt16(offset?:number):number;
		public readShort(offset?:number):number;
		public writeUint16(value:number, offset?:number):ByteBuffer;
		public writeUInt16(value:number, offset?:number):ByteBuffer;
		public readUint16(offset?:number):number;
		public readUInt16(offset?:number):number;
		public writeInt32(value:number, offset?:number):ByteBuffer;
		public writeInt(value:number, offset?:number):ByteBuffer;
		public readInt32(offset?:number):number;
		public readInt(offset?:number):number;
		public writeUint32(value:number, offset?:number):ByteBuffer;
		public writeUInt32(value:number, offset?:number):ByteBuffer;
		public readUint32(offset?:number):number;
		public readUInt32(offset?:number):number;
		public writeInt64(value:any, offset?:number):ByteBuffer;
		public writeLong(value:any, offset?:number):ByteBuffer;
		public readInt64(offset?:number):Long;
		public readLong(offset?:number):Long;
		public writeUint64(value:any, offset?:number):ByteBuffer;
		public writeUInt64(value:any, offset?:number):ByteBuffer;
		public readUint64(offset?:number):Long;
		public readUInt64(offset?:number):Long;
		public writeFloat32(value:number, offset?:number):ByteBuffer;
		public writeFloat(value:number, offset?:number):ByteBuffer;
		public readFloat32(offset?):number;
		public readFloat(offset?):number;
		public writeFloat64(value:number, offset?:number):ByteBuffer;
		public writeDouble(value:number, offset?:number):ByteBuffer;
		public readFloat64(offset?:number):number;
		public readDouble(offset?:number):number;
		public static MAX_VARINT32_BYTES:number;
		public static calculateVarint32(value:number):number;
		public static zigZagEncode32(n:number):number;
		public static zigZagDecode32(n:number):number;
		public writeVarint32(value:number, offset?:number):any;
		public writeVarint32ZigZag(value:number, offset?:number):any;
		public readVarint32(offset?:number):any;
		public readVarint32ZigZag(offset?:number):any;
		public static MAX_VARINT64_BYTES:number;
		public static calculateVarint64(value:any):number;
		public static zigZagEncode64(value:any):Long;
		public static zigZagDecode64(value:any):Long;
		public writeVarint64(value:any, offset?:number):any;
		public writeVarint64ZigZag(value:any, offset?:number):any;
		public readVarint64(offset?:number):any;
		public readVarint64ZigZag(offset?:number):any;
		public writeCString(str:string, offset?:number):any;
		public readCString(offset?:number):any;
		public writeIString(str:string, offset?:number):any;
		public readIString(offset?:number):any;
		public static METRICS_CHARS:string;
		public static METRICS_BYTES:string;
		public writeUTF8String(str:string, offset?:number):any;
		public writeString(str:string, offset?:number):any;
		public static calculateUTF8Chars(str:string):number;
		public static calculateUTF8Bytes(str:string):number;
		public static calculateString(str:string):number;
		public readUTF8String(length:number, metrics?:string, offset?:number):any;
		public readString(length:number, metrics?:string, offset?:number):any;
		public writeVString(str:string, offset?:number):any;
		public readVString(offset?:number):any;
		public append(source:any, encoding?:any, offset?:number):ByteBuffer;
		public appendTo(target:ByteBuffer, offset?:number):ByteBuffer;
		public assert(assert:boolean):ByteBuffer;
		public capacity():number;
		public clear():ByteBuffer;
		public clone(copy?:boolean):ByteBuffer;
		public compact(begin?:number, end?:number):ByteBuffer;
		public copy(begin?:number, end?:number):ByteBuffer;
		public copyTo(target:ByteBuffer, targetOffset?:number, sourceOffset?:number, sourceLimit?:number):ByteBuffer;
		public ensureCapacity(capacity:number):ByteBuffer;
		public fill(value:any, begin?:number, end?:number):ByteBuffer;
		public flip():ByteBuffer;
		public mark(offset?:number):ByteBuffer;
		public order(littleEndian:boolean):ByteBuffer;
		public LE(littleEndian?:boolean):ByteBuffer;
		public BE(bigEndian?:boolean):ByteBuffer;
		public prepend(source:any, encoding?:any, offset?:number):ByteBuffer;
		public prependTo(target:ByteBuffer, offset?:number):ByteBuffer;
		public printDebug(out?:any):void;
		public remaining():number;
		public reset():ByteBuffer;
		public resize(capacity:number):ByteBuffer;
		public reverse(begin?:number, end?:number):ByteBuffer;
		public skip(length:number):ByteBuffer;
		public slice(begin?:number, end?:number):ByteBuffer;
		public toBuffer(forceCopy?:boolean):ArrayBuffer;
		public toArrayBuffer(forceCopy?:boolean):ArrayBuffer;
		public toString(encoding?:string, begin?:number, end?:number):string;
		public toBase64(begin?:number, end?:number):string;
		public static fromBase64(str:string, littleEndian?:boolean):ByteBuffer;
		public static btoa(str:string):string;
		public static atob(b64:string):string;
		public toBinary(begin?:number, end?:number):string;
		public static fromBinary(str:string, littleEndian?:boolean):ByteBuffer;
		public toDebug(columns?:boolean):any;
		public static fromDebug(str:string, littleEndian?:boolean, noAssert?:boolean):ByteBuffer;
		public toHex(begin?:number, end?:number):string;
		public static fromHex(str:string, littleEndian?:boolean, noAssert?:boolean):ByteBuffer;
		public toUTF8(begin?:number, end?:number):string;
		public static fromUTF8(str:string, littleEndian?:boolean, noAssert?:boolean):ByteBuffer;
	}
}